/**
 * Pentest Controller
 *
 * Handles HTTP requests for pentest pipeline operations:
 * - Start pentest
 * - Get progress
 * - Cancel pentest
 * - Get report
 */

import { Response } from 'express';
import { z } from 'zod';
import { prisma } from '../config/database.js';
import { createGitHubService } from '../services/github.service.js';
import { getUserAccessToken } from './auth.controller.js';
import { getDecryptedApiKey } from './apikey.controller.js';
import { AuthenticatedRequest, ApiResponse } from '../types/index.js';
import { NotFoundError, AppError } from '../utils/errors.js';
import { ErrorCode } from '../types/index.js';
import { logger } from '../utils/logger.js';
import {
  startPentest,
  getPentestProgress,
  getPentestSummary,
  getPentestInfo,
  listUserPentests,
  getFinalReport,
  listDeliverables,
  readDeliverable,
  checkPentestHealth,
} from '../services/pentest.service.js';
import { cancelPipeline } from '../temporal/index.js';
import { generatePentestPdf } from '../services/pdf.service.js';

// ============================================================================
// Validation Schemas
// ============================================================================

const startPentestSchema = z.object({
  repositoryId: z.string().uuid(),
  webUrl: z.string().url(),
  branch: z.string().optional(),
  configYaml: z.string().optional(),
});

const listPentestsSchema = z.object({
  page: z.coerce.number().positive().optional().default(1),
  limit: z.coerce.number().positive().max(100).optional().default(20),
  status: z.enum(['PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED']).optional(),
  repositoryId: z.string().uuid().optional(),
});

// ============================================================================
// Start Pentest
// ============================================================================

/**
 * Start a new pentest pipeline
 * POST /api/v1/pentest
 */
export async function startPentestHandler(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const validated = startPentestSchema.parse(req.body);
  const userId = req.user!.id;

  // Verify repository ownership
  const repository = await prisma.repository.findFirst({
    where: {
      id: validated.repositoryId,
      userId,
    },
  });

  if (!repository) {
    throw new NotFoundError('Repository', validated.repositoryId);
  }

  // Get access token for cloning
  const accessToken = await getUserAccessToken(userId);

  // Get user's Anthropic API key from database
  const anthropicApiKey = await getDecryptedApiKey(userId, 'ANTHROPIC');

  if (!anthropicApiKey) {
    throw new AppError(
      'Anthropic API key not configured. Please add your API key in Settings before running a pentest.',
      400,
      ErrorCode.VALIDATION_ERROR
    );
  }

  logger.info('Starting pentest', {
    userId,
    repositoryId: validated.repositoryId,
    webUrl: validated.webUrl,
    hasAnthropicKey: !!anthropicApiKey,
  });

  try {
    // Start pentest via service
    const runInfo = await startPentest({
      userId,
      repositoryId: validated.repositoryId,
      webUrl: validated.webUrl,
      cloneUrl: repository.cloneUrl,
      branch: validated.branch || repository.defaultBranch,
      accessToken,
      configYaml: validated.configYaml,
      anthropicApiKey,  // Pass user's API key
    });

    // Create database record
    const pentestRun = await prisma.pentestRun.create({
      data: {
        userId,
        repositoryId: validated.repositoryId,
        webUrl: validated.webUrl,
        branch: validated.branch || repository.defaultBranch,
        workflowId: runInfo.workflowId,
        status: 'RUNNING',
        startedAt: new Date(),
      },
    });

    logger.info('Pentest started', {
      pentestId: pentestRun.id,
      workflowId: runInfo.workflowId,
    });

    res.status(201).json({
      success: true,
      data: {
        id: pentestRun.id,
        workflowId: runInfo.workflowId,
        status: pentestRun.status,
        webUrl: pentestRun.webUrl,
        repository: {
          id: repository.id,
          name: repository.name,
          fullName: repository.fullName,
        },
        startedAt: pentestRun.startedAt,
      },
    });
  } catch (error: any) {
    logger.error('Failed to start pentest', {
      userId,
      repositoryId: validated.repositoryId,
      error: error.message,
    });

    throw new AppError(
      `Failed to start pentest: ${error.message}`,
      500,
      ErrorCode.INTERNAL_ERROR
    );
  }
}

// ============================================================================
// Get Pentest Progress
// ============================================================================

/**
 * Get pentest progress
 * GET /api/v1/pentest/:id/progress
 */
export async function getPentestProgressHandler(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const pentestId = req.params.id;
  const userId = req.user!.id;

  // Verify ownership
  const pentestRun = await prisma.pentestRun.findFirst({
    where: {
      id: pentestId,
      userId,
    },
    include: {
      repository: {
        select: {
          id: true,
          name: true,
          fullName: true,
        },
      },
    },
  });

  if (!pentestRun) {
    throw new NotFoundError('PentestRun', pentestId);
  }

  // Get progress from Temporal using workflowId
  const progress = await getPentestProgress(pentestRun.workflowId);

  res.json({
    success: true,
    data: {
      id: pentestRun.id,
      status: progress?.status || pentestRun.status,
      currentPhase: progress?.currentPhase || pentestRun.currentPhase,
      currentAgent: progress?.currentAgent || pentestRun.currentAgent,
      completedAgents: progress?.completedAgents || pentestRun.completedAgents,
      skippedAgents: progress?.skippedAgents || pentestRun.skippedAgents,
      failedAgent: progress?.failedAgent || pentestRun.failedAgent,
      elapsedMs: progress?.elapsedMs,
      repository: pentestRun.repository,
      webUrl: pentestRun.webUrl,
      startedAt: pentestRun.startedAt,
    },
  });
}

// ============================================================================
// Get Pentest Details
// ============================================================================

/**
 * Get pentest details
 * GET /api/v1/pentest/:id
 */
export async function getPentestHandler(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const pentestId = req.params.id;
  const userId = req.user!.id;

  const pentestRun = await prisma.pentestRun.findFirst({
    where: {
      id: pentestId,
      userId,
    },
    include: {
      repository: {
        select: {
          id: true,
          name: true,
          fullName: true,
        },
      },
      agentRuns: {
        orderBy: { startedAt: 'asc' },
      },
      pentestReport: true,
    },
  });

  if (!pentestRun) {
    throw new NotFoundError('PentestRun', pentestId);
  }

  res.json({
    success: true,
    data: pentestRun,
  });
}

// ============================================================================
// List Pentests
// ============================================================================

/**
 * List user's pentests
 * GET /api/v1/pentest
 */
export async function listPentestsHandler(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const validated = listPentestsSchema.parse(req.query);
  const userId = req.user!.id;

  const where: any = { userId };

  if (validated.status) {
    where.status = validated.status;
  }

  if (validated.repositoryId) {
    where.repositoryId = validated.repositoryId;
  }

  const [pentests, total] = await Promise.all([
    prisma.pentestRun.findMany({
      where,
      include: {
        repository: {
          select: {
            id: true,
            name: true,
            fullName: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
      skip: (validated.page - 1) * validated.limit,
      take: validated.limit,
    }),
    prisma.pentestRun.count({ where }),
  ]);

  res.json({
    success: true,
    data: pentests,
    meta: {
      page: validated.page,
      limit: validated.limit,
      total,
      totalPages: Math.ceil(total / validated.limit),
    },
  });
}

// ============================================================================
// Cancel Pentest
// ============================================================================

/**
 * Cancel a running pentest
 * POST /api/v1/pentest/:id/cancel
 */
export async function cancelPentestHandler(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const pentestId = req.params.id;
  const userId = req.user!.id;

  const pentestRun = await prisma.pentestRun.findFirst({
    where: {
      id: pentestId,
      userId,
    },
  });

  if (!pentestRun) {
    throw new NotFoundError('PentestRun', pentestId);
  }

  if (pentestRun.status !== 'RUNNING' && pentestRun.status !== 'PENDING') {
    throw new AppError(
      'Can only cancel running or pending pentests',
      400,
      ErrorCode.VALIDATION_ERROR
    );
  }

  // Cancel Temporal workflow directly using workflowId from database
  let cancelled = false;
  try {
    await cancelPipeline(pentestRun.workflowId);
    cancelled = true;
    logger.info('Pentest cancelled successfully', { pentestId, workflowId: pentestRun.workflowId });
  } catch (error) {
    logger.error('Failed to cancel pentest workflow', { pentestId, workflowId: pentestRun.workflowId, error });
    // Even if Temporal cancel fails, we'll still update the database status
    cancelled = true;
  }

  // Update database status
  await prisma.pentestRun.update({
    where: { id: pentestId },
    data: {
      status: 'CANCELLED',
      completedAt: new Date(),
    },
  });

  res.json({
    success: true,
    data: {
      id: pentestId,
      status: 'CANCELLED',
    },
  });
}

// ============================================================================
// Get Report
// ============================================================================

/**
 * Get final pentest report
 * GET /api/v1/pentest/:id/report
 */
export async function getPentestReportHandler(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const pentestId = req.params.id;
  const userId = req.user!.id;

  const pentestRun = await prisma.pentestRun.findFirst({
    where: {
      id: pentestId,
      userId,
    },
    include: {
      pentestReport: true,
    },
  });

  if (!pentestRun) {
    throw new NotFoundError('PentestRun', pentestId);
  }

  if (pentestRun.status !== 'COMPLETED') {
    throw new AppError(
      'Report is only available for completed pentests',
      400,
      ErrorCode.VALIDATION_ERROR
    );
  }

  // Try to get report from database first
  if (pentestRun.pentestReport) {
    res.json({
      success: true,
      data: pentestRun.pentestReport,
    });
    return;
  }

  // Try to get from file system
  const reportContent = await getFinalReport(pentestId);

  if (!reportContent) {
    throw new NotFoundError('PentestReport', pentestId);
  }

  res.json({
    success: true,
    data: {
      id: pentestId,
      content: reportContent,
      format: 'MARKDOWN',
    },
  });
}

// ============================================================================
// Download PDF Report
// ============================================================================

/**
 * Download pentest report as PDF
 * GET /api/v1/pentest/:id/report/pdf
 */
export async function downloadPentestReportPdfHandler(
  req: AuthenticatedRequest,
  res: Response
): Promise<void> {
  const pentestId = req.params.id;
  const userId = req.user!.id;

  const pentestRun = await prisma.pentestRun.findFirst({
    where: {
      id: pentestId,
      userId,
    },
    include: {
      repository: true,
      pentestReport: true,
    },
  });

  if (!pentestRun) {
    throw new NotFoundError('PentestRun', pentestId);
  }

  if (pentestRun.status !== 'COMPLETED') {
    throw new AppError(
      'PDF report is only available for completed pentests',
      400,
      ErrorCode.VALIDATION_ERROR
    );
  }

  if (!pentestRun.pentestReport) {
    throw new NotFoundError('PentestReport', pentestId);
  }

  logger.info('Generating PDF report', { pentestId });

  try {
    const pdfBuffer = await generatePentestPdf({
      id: pentestRun.id,
      repositoryName: pentestRun.repository?.name || 'Unknown Repository',
      webUrl: pentestRun.webUrl,
      branch: pentestRun.branch,
      createdAt: pentestRun.createdAt,
      completedAt: pentestRun.completedAt,
      criticalCount: pentestRun.pentestReport.criticalCount,
      highCount: pentestRun.pentestReport.highCount,
      mediumCount: pentestRun.pentestReport.mediumCount,
      lowCount: pentestRun.pentestReport.lowCount,
      infoCount: pentestRun.pentestReport.infoCount,
      exploitsAttempted: pentestRun.pentestReport.exploitsAttempted,
      exploitsSuccessful: pentestRun.pentestReport.exploitsSuccessful,
      content: pentestRun.pentestReport.content,
      totalCostUsd: pentestRun.totalCostUsd || undefined,
      totalDurationMs: pentestRun.totalDurationMs || undefined,
    });

    // Set headers for PDF download
    const filename = `GitScan-Report-${pentestRun.repository?.name || 'pentest'}-${new Date().toISOString().split('T')[0]}.pdf`;
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.setHeader('Content-Length', pdfBuffer.length);

    res.send(pdfBuffer);
  } catch (error: any) {
    logger.error('Failed to generate PDF report', {
      pentestId,
      error: error.message,
    });
    throw new AppError(
      'Failed to generate PDF report',
      500,
      ErrorCode.INTERNAL_ERROR
    );
  }
}

// ============================================================================
// List Deliverables
// ============================================================================

/**
 * List all deliverables for a pentest
 * GET /api/v1/pentest/:id/deliverables
 */
export async function listDeliverablesHandler(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const pentestId = req.params.id;
  const userId = req.user!.id;

  const pentestRun = await prisma.pentestRun.findFirst({
    where: {
      id: pentestId,
      userId,
    },
  });

  if (!pentestRun) {
    throw new NotFoundError('PentestRun', pentestId);
  }

  const files = await listDeliverables(pentestId);

  res.json({
    success: true,
    data: files,
  });
}

/**
 * Get a specific deliverable
 * GET /api/v1/pentest/:id/deliverables/:filename
 */
export async function getDeliverableHandler(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const pentestId = req.params.id;
  const filename = req.params.filename;
  const userId = req.user!.id;

  const pentestRun = await prisma.pentestRun.findFirst({
    where: {
      id: pentestId,
      userId,
    },
  });

  if (!pentestRun) {
    throw new NotFoundError('PentestRun', pentestId);
  }

  const content = await readDeliverable(pentestId, filename);

  if (!content) {
    throw new NotFoundError('Deliverable', filename);
  }

  res.json({
    success: true,
    data: {
      filename,
      content,
    },
  });
}

// ============================================================================
// Health Check
// ============================================================================

/**
 * Check pentest service health
 * GET /api/v1/pentest/health
 */
export async function getPentestHealthHandler(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const health = await checkPentestHealth();

  res.json({
    success: true,
    data: {
      temporal: health.temporal,
      scanner: health.scanner,
      healthy: health.temporal && health.scanner,
    },
  });
}

// ============================================================================
// SSE Progress Stream
// ============================================================================

/**
 * Stream pentest progress via SSE
 * GET /api/v1/pentest/:id/stream
 */
export async function streamPentestProgress(
  req: AuthenticatedRequest,
  res: Response
): Promise<void> {
  const pentestId = req.params.id;
  const userId = req.user!.id;

  // Verify ownership
  const pentestRun = await prisma.pentestRun.findFirst({
    where: {
      id: pentestId,
      userId,
    },
  });

  if (!pentestRun) {
    res.status(404).json({ error: 'Pentest not found' });
    return;
  }

  // Set SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.flushHeaders();

  // Send progress updates using workflowId
  const sendProgress = async () => {
    const progress = await getPentestProgress(pentestRun.workflowId);
    if (progress) {
      res.write(`data: ${JSON.stringify(progress)}\n\n`);
    }
  };

  // Initial progress
  await sendProgress();

  // Poll every 1 second
  const intervalId = setInterval(async () => {
    const progress = await getPentestProgress(pentestRun.workflowId);
    if (progress) {
      res.write(`data: ${JSON.stringify(progress)}\n\n`);

      // Stop when done
      if (progress.status === 'completed' || progress.status === 'failed' || progress.status === 'cancelled') {
        clearInterval(intervalId);
        res.end();
      }
    }
  }, 1000);

  // Cleanup on disconnect
  req.on('close', () => {
    clearInterval(intervalId);
  });
}
