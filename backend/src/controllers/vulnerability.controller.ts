import { Response } from 'express';
import { z } from 'zod';
import axios from 'axios';
import { prisma } from '../config/database.js';
import { AuthenticatedRequest, ApiResponse, LlmProviderType } from '../types/index.js';
import { NotFoundError, AppError } from '../utils/errors.js';
import { ErrorCode } from '../types/index.js';
import { logger } from '../utils/logger.js';
import { getDecryptedApiKey } from './apikey.controller.js';

const SCANNER_URL = process.env.SCANNER_SERVICE_URL || 'http://scanner:5000';

// Validation schemas
const updateVulnerabilitySchema = z.object({
  status: z.enum(['OPEN', 'IN_PROGRESS', 'FIXED', 'WONT_FIX', 'FALSE_POSITIVE']).optional(),
  falsePositive: z.boolean().optional(),
});

const generateFixSchema = z.object({
  provider: z.enum(['OPENAI', 'ANTHROPIC', 'GOOGLE']).optional(),
  model: z.string().optional(),
});

// List all vulnerabilities for the user
export async function listVulnerabilities(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const { page = 1, limit = 20, severity, status, repositoryId } = req.query;

  const pageNum = parseInt(page as string, 10);
  const limitNum = parseInt(limit as string, 10);
  const skip = (pageNum - 1) * limitNum;

  const where: any = {
    scan: {
      userId: req.user!.id,
    },
  };

  if (severity) {
    where.severity = severity;
  }

  if (status) {
    where.status = status;
  }

  if (repositoryId) {
    where.scan = {
      ...where.scan,
      repositoryId: repositoryId,
    };
  }

  const [vulnerabilities, total] = await Promise.all([
    prisma.vulnerability.findMany({
      where,
      include: {
        scan: {
          select: {
            id: true,
            branch: true,
            repository: {
              select: {
                id: true,
                name: true,
                fullName: true,
              },
            },
          },
        },
        fixes: {
          select: {
            id: true,
            status: true,
          },
        },
      },
      orderBy: [
        { severity: 'desc' },
        { createdAt: 'desc' },
      ],
      skip,
      take: limitNum,
    }),
    prisma.vulnerability.count({ where }),
  ]);

  res.json({
    success: true,
    data: {
      vulnerabilities,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        totalPages: Math.ceil(total / limitNum),
      },
    },
  });
}

// Get vulnerability details
export async function getVulnerability(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const { id } = req.params;

  const vulnerability = await prisma.vulnerability.findFirst({
    where: {
      id,
      scan: {
        userId: req.user!.id,
      },
    },
    include: {
      scan: {
        select: {
          id: true,
          branch: true,
          repository: {
            select: {
              id: true,
              name: true,
              fullName: true,
            },
          },
        },
      },
      fixes: {
        orderBy: { createdAt: 'desc' },
      },
    },
  });

  if (!vulnerability) {
    throw new NotFoundError('Vulnerability', id);
  }

  res.json({
    success: true,
    data: vulnerability,
  });
}

// Update vulnerability status
export async function updateVulnerability(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const { id } = req.params;
  const validated = updateVulnerabilitySchema.parse(req.body);

  // Verify ownership
  const existing = await prisma.vulnerability.findFirst({
    where: {
      id,
      scan: { userId: req.user!.id },
    },
  });

  if (!existing) {
    throw new NotFoundError('Vulnerability', id);
  }

  const vulnerability = await prisma.vulnerability.update({
    where: { id },
    data: validated,
  });

  res.json({
    success: true,
    data: vulnerability,
  });
}

// Generate fix suggestion using LLM
export async function generateFix(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const { id } = req.params;
  const { provider, model } = generateFixSchema.parse(req.body);

  // Get vulnerability with context
  const vulnerability = await prisma.vulnerability.findFirst({
    where: {
      id,
      scan: { userId: req.user!.id },
    },
    include: {
      scan: {
        include: {
          repository: true,
        },
      },
    },
  });

  if (!vulnerability) {
    throw new NotFoundError('Vulnerability', id);
  }

  // Determine which LLM provider to use
  const user = await prisma.user.findUnique({
    where: { id: req.user!.id },
    select: {
      id: true,
      defaultLlmProvider: true,
    },
  });

  const llmProvider = (provider || user?.defaultLlmProvider || 'OPENAI') as LlmProviderType;

  // Get API key for the provider
  const apiKey = await getDecryptedApiKey(req.user!.id, llmProvider);

  if (!apiKey) {
    throw new AppError(
      `No API key configured for ${llmProvider}. Please add your API key in Settings.`,
      400,
      ErrorCode.VALIDATION_ERROR
    );
  }

  logger.info('Generating fix', {
    vulnerabilityId: id,
    provider: llmProvider,
    model: model,
  });

  // Determine file language from extension
  const fileExt = vulnerability.filePath.split('.').pop()?.toLowerCase() || 'javascript';
  const languageMap: Record<string, string> = {
    'js': 'javascript',
    'jsx': 'javascript',
    'ts': 'typescript',
    'tsx': 'typescript',
    'py': 'python',
    'java': 'java',
    'go': 'go',
    'rb': 'ruby',
    'php': 'php',
    'cs': 'csharp',
  };
  const language = languageMap[fileExt] || fileExt;

  // Create fix record with PENDING status
  const fix = await prisma.fix.create({
    data: {
      vulnerabilityId: id,
      originalCode: vulnerability.codeSnippet || '',
      fixedCode: '',
      explanation: '',
      llmProvider,
      llmModel: model || getDefaultModel(llmProvider),
      status: 'PENDING',
    },
  });

  // Call scanner service LLM endpoint asynchronously
  callScannerLLM(fix.id, {
    provider: llmProvider,
    model: model || getDefaultModel(llmProvider),
    apiKey,
    vulnerability: {
      title: vulnerability.title,
      description: vulnerability.description,
      category: vulnerability.category,
      file_path: vulnerability.filePath,
      code_snippet: vulnerability.codeSnippet || '',
      language,
      cwe_id: vulnerability.cweId || undefined,
      suggested_fix: vulnerability.suggestedFix || undefined,
    },
  }).catch((error) => {
    logger.error('LLM fix generation failed', { fixId: fix.id, error: error.message });
  });

  res.status(201).json({
    success: true,
    data: {
      ...fix,
      message: 'Fix generation started. Check back shortly for results.',
    },
  });
}

// Get default model for provider
function getDefaultModel(provider: LlmProviderType): string {
  const defaults: Record<LlmProviderType, string> = {
    OPENAI: 'gpt-4o',
    ANTHROPIC: 'claude-sonnet-4-5-20250514',
    GOOGLE: 'gemini-2.0-flash',
  };
  return defaults[provider];
}

// Call scanner LLM service
async function callScannerLLM(
  fixId: string,
  params: {
    provider: string;
    model: string;
    apiKey: string;
    vulnerability: {
      title: string;
      description: string;
      category: string;
      file_path: string;
      code_snippet: string;
      language: string;
      cwe_id?: string;
      suggested_fix?: string;
    };
  }
): Promise<void> {
  try {
    const response = await axios.post(`${SCANNER_URL}/api/llm/generate-fix`, {
      provider: params.provider,
      model: params.model,
      api_key: params.apiKey,
      vulnerability: params.vulnerability,
    }, {
      timeout: 120000, // 2 minutes
    });

    if (response.data.success) {
      // Update fix with generated code
      await prisma.fix.update({
        where: { id: fixId },
        data: {
          fixedCode: response.data.data.fixed_code,
          explanation: response.data.data.explanation,
          llmModel: response.data.data.model,
          status: 'APPLIED',
        },
      });

      logger.info('Fix generated successfully', { fixId });
    } else {
      throw new Error(response.data.error || 'Unknown error from LLM service');
    }
  } catch (error: any) {
    // Update fix status to failed
    await prisma.fix.update({
      where: { id: fixId },
      data: {
        status: 'FAILED',
        explanation: `Error: ${error.message}`,
      },
    });

    throw error;
  }
}

// Apply fix and create PR
export async function applyFix(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const { id } = req.params;
  const { fixId } = req.body;

  // Get vulnerability with fix
  const vulnerability = await prisma.vulnerability.findFirst({
    where: {
      id,
      scan: { userId: req.user!.id },
    },
    include: {
      fixes: {
        where: { id: fixId },
      },
      scan: {
        include: {
          repository: true,
        },
      },
    },
  });

  if (!vulnerability) {
    throw new NotFoundError('Vulnerability', id);
  }

  const fix = vulnerability.fixes[0];
  if (!fix) {
    throw new NotFoundError('Fix', fixId);
  }

  if (!fix.fixedCode) {
    throw new AppError('Fix has no generated code yet', 400, ErrorCode.VALIDATION_ERROR);
  }

  // Get user's GitHub token
  const user = await prisma.user.findUnique({
    where: { id: req.user!.id },
    select: { accessToken: true },
  });

  if (!user?.accessToken) {
    throw new AppError('GitHub access token not found', 401, ErrorCode.GITHUB_AUTH_FAILED);
  }

  const { createGitHubService } = await import('../services/github.service.js');
  const github = createGitHubService(user.accessToken);

  const repository = vulnerability.scan.repository;
  const [owner, repo] = repository.fullName.split('/');
  const baseBranch = vulnerability.scan.branch;
  const filePath = vulnerability.filePath;

  logger.info('Applying fix to GitHub', {
    vulnerabilityId: id,
    fixId,
    repository: repository.fullName,
    filePath,
    baseBranch,
  });

  try {
    // 1. Get the current commit SHA of the base branch
    const baseSha = await github.getCommitSha(owner, repo, baseBranch);

    // 2. Create a new branch name
    const timestamp = Date.now();
    const sanitizedTitle = vulnerability.title.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .substring(0, 30);
    const newBranchName = `gitscan-fix/${sanitizedTitle}-${timestamp}`;

    // 3. Create the new branch
    await github.createBranch(owner, repo, newBranchName, baseSha);

    // 4. Get the current file content and SHA
    const fileContent = await github.getContents(owner, repo, filePath, baseBranch);
    const currentContent = Buffer.from(fileContent.content, 'base64').toString('utf-8');
    const fileSha = fileContent.sha;

    // 5. Replace the vulnerable code with the fixed code
    const originalCode = fix.originalCode;
    const fixedCode = fix.fixedCode;

    let newContent = currentContent;
    if (currentContent.includes(originalCode)) {
      newContent = currentContent.replace(originalCode, fixedCode);
    } else {
      // If exact match not found, try to apply at the specific line
      const lines = currentContent.split('\n');
      const startLine = vulnerability.startLine - 1;
      const endLine = vulnerability.endLine;
      const fixedLines = fixedCode.split('\n');
      lines.splice(startLine, endLine - startLine, ...fixedLines);
      newContent = lines.join('\n');
    }

    // 6. Commit the fix to the new branch
    const commitMessage = `üîí Fix: ${vulnerability.title}

Fixed vulnerability in ${filePath}

Category: ${vulnerability.category}
Severity: ${vulnerability.severity}
${vulnerability.cweId ? `CWE: ${vulnerability.cweId}` : ''}

ü§ñ Auto-generated by GitScan Security Scanner`;

    await github.createOrUpdateFile(
      owner,
      repo,
      filePath,
      newContent,
      commitMessage,
      newBranchName,
      fileSha
    );

    // 7. Create Pull Request
    const prTitle = `üîí Security Fix: ${vulnerability.title}`;
    const prBody = `## Security Vulnerability Fix

### Vulnerability Details
- **Title:** ${vulnerability.title}
- **Severity:** ${vulnerability.severity}
- **Category:** ${vulnerability.category}
- **File:** \`${filePath}\`
- **Lines:** ${vulnerability.startLine}-${vulnerability.endLine}
${vulnerability.cweId ? `- **CWE:** ${vulnerability.cweId}` : ''}

### Description
${vulnerability.description}

### Fix Applied
${fix.explanation || 'Automated security fix generated by AI.'}

### Original Code
\`\`\`
${fix.originalCode}
\`\`\`

### Fixed Code
\`\`\`
${fix.fixedCode}
\`\`\`

---
ü§ñ *This PR was automatically generated by [GitScan Security Scanner](https://github.com/gitscan)*

‚ö†Ô∏è **Please review the changes carefully before merging.**`;

    const pr = await github.createPullRequest(
      owner,
      repo,
      prTitle,
      prBody,
      newBranchName,
      baseBranch
    );

    // 8. Update fix record with PR info
    const updatedFix = await prisma.fix.update({
      where: { id: fixId },
      data: {
        status: 'APPLIED',
        prUrl: pr.html_url,
        prNumber: pr.number,
      },
    });

    // 9. Update vulnerability status
    await prisma.vulnerability.update({
      where: { id },
      data: { status: 'IN_PROGRESS' },
    });

    logger.info('Fix applied successfully', {
      vulnerabilityId: id,
      fixId,
      prNumber: pr.number,
      prUrl: pr.html_url,
    });

    res.json({
      success: true,
      data: {
        message: 'Fix applied successfully! Pull request created.',
        fix: updatedFix,
        pullRequest: {
          number: pr.number,
          url: pr.html_url,
          branch: newBranchName,
        },
      },
    });
  } catch (error: any) {
    logger.error('Failed to apply fix', {
      vulnerabilityId: id,
      fixId,
      error: error.message,
    });

    // Update fix status to failed
    await prisma.fix.update({
      where: { id: fixId },
      data: {
        status: 'FAILED',
        explanation: fix.explanation + `\n\nError applying fix: ${error.message}`,
      },
    });

    throw new AppError(
      `Failed to apply fix: ${error.message}`,
      500,
      ErrorCode.INTERNAL_ERROR
    );
  }
}

// Get fix history for a vulnerability
export async function getFixHistory(
  req: AuthenticatedRequest,
  res: Response<ApiResponse>
): Promise<void> {
  const { id } = req.params;

  // Verify ownership
  const vulnerability = await prisma.vulnerability.findFirst({
    where: {
      id,
      scan: { userId: req.user!.id },
    },
    select: { id: true },
  });

  if (!vulnerability) {
    throw new NotFoundError('Vulnerability', id);
  }

  const fixes = await prisma.fix.findMany({
    where: { vulnerabilityId: id },
    orderBy: { createdAt: 'desc' },
  });

  res.json({
    success: true,
    data: fixes,
  });
}
