/**
 * Pentest Service
 *
 * Orchestrates pentest pipeline operations:
 * - Starts Temporal workflows
 * - Integrates with scanner-service for static analysis
 * - Manages pentest sessions
 * - Provides progress tracking
 */

import axios from 'axios';
import * as fs from 'fs-extra';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import {
  startPentestPipeline,
  getPipelineProgress,
  getPipelineSummary,
  cancelPipeline,
  checkTemporalHealth,
  PipelineInput,
  PipelineProgress,
  PipelineSummary,
  VulnerabilityFinding,
} from '../temporal';
import { logger } from '../utils/logger';

// ============================================================================
// Configuration
// ============================================================================

const SCANNER_URL = process.env.SCANNER_SERVICE_URL || 'http://scanner:5000';
const PENTEST_BASE_DIR = process.env.PENTEST_BASE_DIR || '/tmp/pentest';

// ============================================================================
// Types
// ============================================================================

export interface PentestStartInput {
  userId: string;
  repositoryId: string;
  webUrl: string;
  cloneUrl: string;
  branch?: string;
  accessToken?: string;
  configYaml?: string;
}

export interface PentestRunInfo {
  pentestId: string;
  workflowId: string;
  status: string;
  webUrl: string;
  repositoryId: string;
  createdAt: Date;
}

export interface ScannerResult {
  scan_id: string;
  status: string;
  total_files: number;
  files_scanned: number;
  vulnerabilities: ScannerVulnerability[];
  summary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
    total: number;
  };
}

export interface ScannerVulnerability {
  title: string;
  description: string;
  severity: string;
  category: string;
  file_path: string;
  start_line: number;
  end_line: number;
  code_snippet?: string;
  cwe_id?: string;
  suggested_fix?: string;
}

// ============================================================================
// In-memory Store (TODO: Move to Redis/DB in production)
// ============================================================================

const pentestRuns = new Map<string, PentestRunInfo>();

// ============================================================================
// Main Service Functions
// ============================================================================

/**
 * Start a new pentest pipeline
 */
export async function startPentest(input: PentestStartInput): Promise<PentestRunInfo> {
  const pentestId = uuidv4();

  logger.info('Starting pentest', {
    pentestId,
    webUrl: input.webUrl,
    repositoryId: input.repositoryId,
  });

  // Create session directory
  const sessionDir = path.join(PENTEST_BASE_DIR, pentestId);
  await fs.ensureDir(sessionDir);
  await fs.ensureDir(path.join(sessionDir, 'deliverables'));

  // Save config if provided
  let configPath: string | undefined;
  if (input.configYaml) {
    configPath = path.join(sessionDir, 'config.yaml');
    await fs.writeFile(configPath, input.configYaml);
  }

  // Prepare pipeline input
  const pipelineInput: PipelineInput = {
    webUrl: input.webUrl,
    repoPath: input.cloneUrl, // Will be cloned by pre-recon agent
    repositoryId: input.repositoryId,
    userId: input.userId,
    branch: input.branch,
    configPath,
  };

  // Start Temporal workflow
  const { workflowId, runId } = await startPentestPipeline(pipelineInput);

  // Store run info
  const runInfo: PentestRunInfo = {
    pentestId,
    workflowId,
    status: 'RUNNING',
    webUrl: input.webUrl,
    repositoryId: input.repositoryId,
    createdAt: new Date(),
  };

  pentestRuns.set(pentestId, runInfo);

  logger.info('Pentest started', { pentestId, workflowId, runId });

  return runInfo;
}

/**
 * Get pentest progress
 */
export async function getPentestProgress(pentestId: string): Promise<PipelineProgress | null> {
  const runInfo = pentestRuns.get(pentestId);
  if (!runInfo) {
    logger.warn('Pentest not found', { pentestId });
    return null;
  }

  try {
    return await getPipelineProgress(runInfo.workflowId);
  } catch (error) {
    logger.error('Failed to get pentest progress', { pentestId, error });
    return null;
  }
}

/**
 * Get pentest summary
 */
export async function getPentestSummary(pentestId: string): Promise<PipelineSummary | null> {
  const runInfo = pentestRuns.get(pentestId);
  if (!runInfo) {
    return null;
  }

  try {
    return await getPipelineSummary(runInfo.workflowId);
  } catch (error) {
    logger.error('Failed to get pentest summary', { pentestId, error });
    return null;
  }
}

/**
 * Cancel a running pentest
 */
export async function cancelPentest(pentestId: string): Promise<boolean> {
  const runInfo = pentestRuns.get(pentestId);
  if (!runInfo) {
    return false;
  }

  try {
    await cancelPipeline(runInfo.workflowId);
    runInfo.status = 'CANCELLED';
    pentestRuns.set(pentestId, runInfo);
    return true;
  } catch (error) {
    logger.error('Failed to cancel pentest', { pentestId, error });
    return false;
  }
}

/**
 * Get pentest run info
 */
export function getPentestInfo(pentestId: string): PentestRunInfo | null {
  return pentestRuns.get(pentestId) || null;
}

/**
 * List all pentest runs for a user
 */
export function listUserPentests(userId: string): PentestRunInfo[] {
  return Array.from(pentestRuns.values());
  // TODO: Filter by userId when persisted to database
}

// ============================================================================
// Scanner Integration (for pre-recon agent)
// ============================================================================

/**
 * Call scanner-service for static analysis
 * Used by pre-recon agent to get initial vulnerability scan
 */
export async function runStaticAnalysis(
  sessionId: string,
  cloneUrl: string,
  branch: string,
  accessToken?: string
): Promise<ScannerResult> {
  logger.info('Running static analysis', { sessionId, cloneUrl, branch });

  const scannerClient = axios.create({
    baseURL: SCANNER_URL,
    timeout: 600000, // 10 minutes
    headers: { 'Content-Type': 'application/json' },
  });

  try {
    const response = await scannerClient.post<ScannerResult>('/api/scanner/scan', {
      scan_id: sessionId,
      repository: {
        clone_url: cloneUrl,
        branch: branch,
        access_token: accessToken,
      },
      options: {
        scan_type: 'FULL',
      },
    });

    logger.info('Static analysis completed', {
      sessionId,
      totalFiles: response.data.total_files,
      vulnerabilities: response.data.summary.total,
    });

    return response.data;
  } catch (error: any) {
    logger.error('Static analysis failed', {
      sessionId,
      error: error.message,
    });
    throw error;
  }
}

/**
 * Convert scanner results to code analysis deliverable
 */
export async function createCodeAnalysisDeliverable(
  sessionDir: string,
  scannerResult: ScannerResult
): Promise<void> {
  const deliverablePath = path.join(sessionDir, 'deliverables', 'code_analysis_deliverable.md');

  const content = generateCodeAnalysisMarkdown(scannerResult);

  await fs.writeFile(deliverablePath, content);

  logger.info('Code analysis deliverable created', { path: deliverablePath });
}

/**
 * Generate markdown content for code analysis deliverable
 */
function generateCodeAnalysisMarkdown(result: ScannerResult): string {
  const lines: string[] = [
    '# Code Analysis Report',
    '',
    '## Executive Summary',
    '',
    `Static code analysis completed with **${result.summary.total} findings**.`,
    '',
    '## Vulnerability Summary',
    '',
    '| Severity | Count |',
    '|----------|-------|',
    `| Critical | ${result.summary.critical} |`,
    `| High | ${result.summary.high} |`,
    `| Medium | ${result.summary.medium} |`,
    `| Low | ${result.summary.low} |`,
    `| Info | ${result.summary.info} |`,
    `| **Total** | **${result.summary.total}** |`,
    '',
    '## Scan Statistics',
    '',
    `- Total Files: ${result.total_files}`,
    `- Files Scanned: ${result.files_scanned}`,
    '',
  ];

  // Group vulnerabilities by category
  const byCategory = new Map<string, ScannerVulnerability[]>();
  for (const vuln of result.vulnerabilities) {
    const category = vuln.category || 'OTHER';
    if (!byCategory.has(category)) {
      byCategory.set(category, []);
    }
    byCategory.get(category)!.push(vuln);
  }

  lines.push('## Findings by Category', '');

  for (const [category, vulns] of byCategory) {
    lines.push(`### ${category}`, '');

    for (let i = 0; i < vulns.length; i++) {
      const vuln = vulns[i];
      lines.push(`#### ${i + 1}. ${vuln.title}`, '');
      lines.push(`- **Severity**: ${vuln.severity}`);
      lines.push(`- **File**: \`${vuln.file_path}:${vuln.start_line}\``);
      if (vuln.cwe_id) {
        lines.push(`- **CWE**: ${vuln.cwe_id}`);
      }
      lines.push('');
      lines.push('**Description**:', vuln.description, '');

      if (vuln.code_snippet) {
        lines.push('**Code**:', '```', vuln.code_snippet, '```', '');
      }

      if (vuln.suggested_fix) {
        lines.push('**Suggested Fix**:', vuln.suggested_fix, '');
      }

      lines.push('---', '');
    }
  }

  lines.push(
    '## Recommendations for Further Testing',
    '',
    'Based on the static analysis, the following areas should be investigated:',
    ''
  );

  if (result.summary.critical > 0 || result.summary.high > 0) {
    lines.push('1. **Critical/High severity findings** require immediate attention');
  }

  const categories = Array.from(byCategory.keys());
  if (categories.includes('SQL_INJECTION') || categories.includes('COMMAND_INJECTION')) {
    lines.push('2. **Injection vulnerabilities** should be validated with dynamic testing');
  }
  if (categories.includes('XSS')) {
    lines.push('3. **XSS vulnerabilities** should be tested in browser context');
  }
  if (categories.includes('AUTHENTICATION') || categories.includes('AUTHORIZATION')) {
    lines.push('4. **Auth issues** require authentication flow testing');
  }

  lines.push(
    '',
    '---',
    '*Generated by GitScan Pre-Recon Agent*'
  );

  return lines.join('\n');
}

// ============================================================================
// Deliverables Management
// ============================================================================

/**
 * Read a deliverable file
 */
export async function readDeliverable(
  pentestId: string,
  filename: string
): Promise<string | null> {
  const filePath = path.join(PENTEST_BASE_DIR, pentestId, 'deliverables', filename);

  if (!(await fs.pathExists(filePath))) {
    return null;
  }

  return fs.readFile(filePath, 'utf8');
}

/**
 * List all deliverables for a pentest
 */
export async function listDeliverables(pentestId: string): Promise<string[]> {
  const deliverablesDir = path.join(PENTEST_BASE_DIR, pentestId, 'deliverables');

  if (!(await fs.pathExists(deliverablesDir))) {
    return [];
  }

  return fs.readdir(deliverablesDir);
}

/**
 * Get final report
 */
export async function getFinalReport(pentestId: string): Promise<string | null> {
  return readDeliverable(pentestId, 'comprehensive_security_assessment_report.md');
}

// ============================================================================
// Health Check
// ============================================================================

/**
 * Check if pentest service is healthy
 */
export async function checkPentestHealth(): Promise<{
  temporal: boolean;
  scanner: boolean;
}> {
  const [temporalHealth, scannerHealth] = await Promise.all([
    checkTemporalHealth().catch(() => false),
    checkScannerHealth().catch(() => false),
  ]);

  return {
    temporal: temporalHealth,
    scanner: scannerHealth,
  };
}

async function checkScannerHealth(): Promise<boolean> {
  try {
    const response = await axios.get(`${SCANNER_URL}/health`, { timeout: 5000 });
    return response.data?.status === 'healthy';
  } catch {
    return false;
  }
}

// ============================================================================
// Cleanup
// ============================================================================

/**
 * Clean up pentest session files
 */
export async function cleanupPentest(pentestId: string): Promise<void> {
  const sessionDir = path.join(PENTEST_BASE_DIR, pentestId);

  if (await fs.pathExists(sessionDir)) {
    await fs.remove(sessionDir);
    logger.info('Pentest session cleaned up', { pentestId });
  }

  pentestRuns.delete(pentestId);
}
